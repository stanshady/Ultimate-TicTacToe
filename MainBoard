package v1;

import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.StrokeLineCap;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.util.Duration;
import java.util.ArrayList;

public class MainBoard extends Application {

    private static final int TILE_WIDTH = 90;
    private static final int TILE_HEIGHT = 90;

    private static Rectangle background = new Rectangle(0, 0, TILE_WIDTH * 9, TILE_HEIGHT * 9);
    private static int[] lastClicked = new int[2];
    private static boolean xTurn = true;
    private static boolean playable = true;
    private static LocalBoard[][] globalBoard = new LocalBoard[3][3];
    private static ArrayList<BoardCombo> boardCombos = new ArrayList<>();
    private static Pane root = new Pane();

    private Parent createContent() {

        root.setPrefSize(TILE_WIDTH * 9, TILE_HEIGHT * 9);

        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 3; col++) {
                LocalBoard localBoard = new LocalBoard(TILE_WIDTH, TILE_HEIGHT);
                localBoard.setTranslateX(row * TILE_WIDTH * 3);
                localBoard.setTranslateY(col * TILE_HEIGHT * 3);

                globalBoard[row][col] = localBoard;

                root.getChildren().addAll(localBoard);
            }
        }

        //add da combos
        for (int row = 0; row < 3; row++) {
            boardCombos.add(new BoardCombo(globalBoard[row][0],
                    globalBoard[row][1],
                    globalBoard[row][2]));
        }
        for (int col = 0; col < 3; col++) {
            boardCombos.add(new BoardCombo(globalBoard[0][col],
                    globalBoard[1][col],
                    globalBoard[2][col]));
        }
        boardCombos.add(new BoardCombo(globalBoard[0][0],
                globalBoard[1][1],
                globalBoard[2][2]));
        boardCombos.add(new BoardCombo(globalBoard[0][2],
                globalBoard[1][1],
                globalBoard[2][0]));

        return root;
    }

    public void start(Stage primaryStage) {
        primaryStage.setScene(new Scene(createContent()));
        primaryStage.setTitle("Ultimate Tic-Tac-Toe");
        primaryStage.show();
    }

    //this like the most important one
    public static void update() {
        //check for winner
        for (BoardCombo boardCombo : boardCombos) {
            if (boardCombo.isComplete()) {
                playable = false;
                playWinAnimation(boardCombo);
                break; //if no break, then more than one line can be drawn sometimes
            }
        }

        //check for draw
        if (playable)
            if (isDraw()) {
                playable = false;
                displayWinner(false);
            }

        for (int r = 0; r < 3; r++) {
            for (int c = 0; c < 3; c++) {
                globalBoard[r][c].border().setStroke(null);
            }
        }

        if (playable) { //lastClicked square is available
            if (globalBoard[lastClicked[0]][lastClicked[1]].isLocalPlayable())
                globalBoard[lastClicked[0]][lastClicked[1]].border().setStroke(Color.BLACK);
            else
                //lastClicked was not available. All playable squares are highlighted
                for (int r = 0; r < 3; r++)
                    for (int c = 0; c < 3; c++)
                        if (globalBoard[r][c].isLocalPlayable())
                            globalBoard[r][c].border().setStroke(Color.BLACK);
        }
    }

    public static boolean isDraw() {
        boolean draw = true;
        for (int r = 0; r < 3; r++)
            for (int c = 0; c < 3; c++)
                if (globalBoard[r][c].isLocalPlayable())
                    draw = false;
        return draw;
    }

    public static void displayWinner(boolean isWon) {
        //background fades to white to announce winner
        background.setFill(Color.WHITE);
        background.setOpacity(0);

        root.getChildren().addAll(background);

        //winning line animation is 500 millis long.
        //I put an additional 500 delay as default.
        double delay = 500;
        if (isWon)
            delay = 1000;

        //fade to white
        Timeline timeline = new Timeline();
        KeyFrame endFrame = new KeyFrame(Duration.millis(2000),
                new KeyValue(background.opacityProperty(), .8));
        timeline.getKeyFrames().addAll(endFrame);
        timeline.setDelay(Duration.millis(delay));
        timeline.play();

        //winningText
        Text winningText = new Text();
        winningText.setText("X Wins");
        if (xTurn)
            winningText.setText("O Wins");
        if(!isWon)
            winningText.setText(" Draw ");
        winningText.setOpacity(0);
        winningText.setFont(new Font(TILE_WIDTH * 2));
        winningText.setStroke(Color.BLACK);
        winningText.setTranslateX(1.35 * TILE_WIDTH);
        winningText.setTranslateY(5 * TILE_HEIGHT);
        root.getChildren().addAll(winningText);

        //Fade in winningText
        Timeline timeline2 = new Timeline();
        endFrame = new KeyFrame(Duration.millis(1500),
                new KeyValue(winningText.opacityProperty(), 1));
        timeline2.getKeyFrames().addAll(endFrame);
        timeline2.setDelay(Duration.millis(1500));
        timeline2.play();
    }

    public static void playWinAnimation(BoardCombo boardCombo) {
        Line line = new Line(boardCombo.localBoards[0].getXCenter(),
                boardCombo.localBoards[0].getYCenter(),
                boardCombo.localBoards[0].getXCenter(),
                boardCombo.localBoards[0].getYCenter());
        line.setStrokeWidth(0.5 * TILE_WIDTH);
        line.setStroke(Color.BLACK);
        line.setStrokeLineCap(StrokeLineCap.ROUND);

        root.getChildren().addAll(line);

        //draw the line
        Timeline timeline0 = new Timeline();
        KeyFrame endFrame = new KeyFrame(Duration.millis(500),
                new KeyValue(line.endXProperty(), boardCombo.localBoards[2].getXCenter()),
                new KeyValue(line.endYProperty(), boardCombo.localBoards[2].getYCenter()));
        timeline0.getKeyFrames().addAll(endFrame);
        timeline0.play();

        displayWinner(true);
    }

    //this sucks.  don't use
    private void replayBox() {
        /* Replay box:
         * StackPane <- Vbox <-(Label, HBox <-(ButtonYes, ButtonNo))
         */
        Button yes = new Button("Yes");
        Button no = new Button("No");

        Label playAgain = new Label("Play Again?");
        HBox hBox = new HBox(5);
        hBox.getChildren().addAll(yes, no);

        VBox vBox = new VBox(10);
        vBox.getChildren().addAll(playAgain, hBox);

        Rectangle hideReplayBox = new Rectangle(100, 100);
        hideReplayBox.setFill(Color.WHITE);

        StackPane replayPane = new StackPane();
        replayPane.getChildren().addAll(vBox, hideReplayBox);
        replayPane.setTranslateX(TILE_WIDTH * 4);
        replayPane.setTranslateY(TILE_HEIGHT * 5.2);

        //Get rid of hideReplayBox
        Timeline timeline3 = new Timeline();
        KeyFrame endFrame = new KeyFrame(Duration.millis(1),
                new KeyValue(hideReplayBox.opacityProperty(), 0));
        timeline3.getKeyFrames().addAll(endFrame);
        timeline3.setDelay(Duration.millis(3000));
        timeline3.play();

        root.getChildren().addAll(replayPane);
    }

    public static boolean getXTurn() {
        return xTurn;
    }

    public static void setXTurn(boolean b) {
        xTurn = b;
    }

    public static boolean getPlayable() {
        return playable;
    }

    public static void setLastClicked(int row, int col) {
        lastClicked[0] = row;
        lastClicked[1] = col;
    }


    private class BoardCombo {
        private LocalBoard[] localBoards;

        BoardCombo(LocalBoard... localBoards) {
            this.localBoards = localBoards;
        }

        public boolean isComplete() {
            if (localBoards[0].isEmpty())
                return false;

            return localBoards[0].getText().equals(localBoards[1].getText())
                    && localBoards[1].getText().equals(localBoards[2].getText());
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}
